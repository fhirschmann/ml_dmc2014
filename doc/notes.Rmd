This document gets compiled automatically with each svn commit and is available at:
[http://dmc.0x0b.de](http://dmc.0x0b.de).

```{r setup, echo=F}
library(knitr)
opts_chunk$set(echo=T, breaklines=T)
opts_knit$set(fig.path="figure-notes/", root.dir="../")
```
```{r echo=F}
source("R/data.R")
source("R/utils.R")
source("R/dmc2010.R")
library(xtable)
library(ggplot2)
```
# DMC 2010 Notes

The task is to classify the target attribute ``target90`` (binary classification). If this
attribute is ``yes``, then no vouchers are given out and vice versa. So, the decision to
give out vouchers really is the inverse of ``target90``.

## Basic Numbers

### Maximum Points

The maximum achievable points:
```{r max}
points.max <- dmc.points(dt$target90, dt$target90)
points.max
```

### Baseline

The baseline can be constructed by giving out a voucher all the time:

```{r baseline}
points.baseline <- dmc.points(rep("no", nrow(dt)), dt$target90)
points.baseline
```

In terms of ratio:

```{r baseliner}
points.baseline / points.max
```


## Cost-Sensitivity

The problem at hand is a cost-sensitive classification problem, and
the cost matrix is given by

```{r cost}
dmc.cost
```

where columns correspond to the true classes and rows are the predicted class.
Diagonal elements are ignored, so it needs to be normalized.

## Data Analytics

### Data types

After preprocessing, the predictors have the following types:

```{r types}
df.classes(dt)
```

### Data Summary

```{r summary}
summary(dt.unclean)
```

Observations:

- ``gift`` has very few yes cases, as does ``title``
- ``points`` is useless
- ``deliverydatepromises`` has at least one outlier (mean vs median!)
- ``deliverydatediff`` is affected by this obviously
- ``weight`` probably has at least one outlier too (mean vs median!)

## Outlier Handling
Let's take a look at the date outliers. 

First, we'll look the date outliers:
```{r dates}
outliers <- dt.unclean$deliverydatepromised > as.Date("2011-01-01")
of.interest <- c("date", "deliverydatepromised", "deliverydatereal",
                 "deliverydatediff", "datecreated")
options(width=160)
dt.unclean[outliers, of.interest]
```
- Assumption: Just the year is incorrect
- Solution: replace the year in deliverydatepromised with the year in date
```{r dates2}
dt[outliers, of.interest]
```
Next, we'll look at outliers which were
delivered more than one year after the purchase:
```{r dates3}
outliers <- dt.unclean$deliverydatediff < -350 & !is.na(dt.unclean$deliverydatediff)
dt.unclean[outliers, of.interest]
```
- Assumption: the date in deliverydatereal is off by 1 year
- Solution: Subtract 1 year from deliverydatereal
```{r dates4}
dt[outliers, of.interest]
```
What about the other way?
```{r dates5}
outliers <- dt.unclean$deliverydatediff > 350 & !is.na(dt.unclean$deliverydatediff)
dt.unclean[outliers, of.interest]
```
Don't worry about the instances with deliverydatediff = 1000000. These are due to
the instances with deliverydatepromised > 4000 and have already been handled.

However, the same can be said about > 350 as with < -350. Let's fix it:
```{r dates6}
dt[outliers, of.interest]
```
Looks about right now, doesn't it?
```{r datesm}
summary(dt.unclean$deliverydatediff)
summary(dt$deliverydatediff)
```
Still not perfect (black dots are outliers):
```{r dateplot}
smoothScatter(dt$deliverydatediff)
```
## Visual Stuff

```{r barplots, fig.width=11}
toplot <- c("weekday", "dom")
qplot(domain, fill=group, data=dt.merged, position="dodge") + theme(axis.text.x = element_text(angle=90))

```